# Прототип функције

У већини задатака прво дефинишемо функције, па их затим користимо у главном програму.
Овај след је неопходан, како би их главна функција main() препознала.

Могуће је дефинисати функције и после главне функције. Међутим, у том случају треба
користити прототип функције који се наводи на почетку. Он обухвата само заглавље
функција уз обавезан знак ; на крају.

У следећем примеру је употребљен прототип:

```c
#include<stdio.h>
int zbir(int a, int b);
int main(void)
{
    printf("Zbir brojeva 5 i 8 je %d", zbir(5, 8));
	return 0;
}

int zbir(int a, int b)
{
    return a + b;
}
```

У примерима које ћемо обрадити користићемо често и прототип функција.

Користећи функције решићемо неколико не толико тешких задатака.


```{questionnote}
Написати програм за израчунавање израза  $m = \frac {а^3+b^3} {c^3-d^3}$ користећи функцију
`kub(a)`. Приликом њеног креирања користити системску функцију за степеновање `pow(a, n)`
која се налази у заглављу `math.h`.
```

**Решење**:

Овде уочаваш да се функција kub коју ћемо креирати позива у изразу у главном програму
четири пута. Ту се види пун смисао коришћења једном креиране функције.

Како ћемо користити системску математичку функцију, морамо позвати заглавље `math.h`.
Ту функцију ћемо користити приликом креирања наше функције.

```{infonote}
Општи облик функције pow је `double pow(double x, double y)`. Она враћа
резултат степеновања $x^y$.
```

```c
#include<stdio.h>
#include<math.h>
double kub(double a);

//Главни програм

int main(void)
{
    double a, b, c, d;
    printf("Unesi brojeve a, b, c, d:\n");
    scanf("%lf%lf%lf%lf", &a, &b, &c, &d);
    printf("m = %.2f\n", (kub(a) + kub(b)) / (kub(c) - kub(d)));
}

double kub(double a)
{
    double k;
    k = pow(a, 3);
    return k;
}
```

Резултат извршавања програма:

```text
Unesi brojeve a, b, c, d:
4 3 2 1

m = 13.00
```

```{questionnote}
Написати функцију за израчунавање броја комбинација дужине *m* од *n* елемената
по формули. Задатак решити користећи функцију факторијел.
```

**Решење**:

Немој да се збуниш, у овом задатку се не тражи твоје предзнање из комбинаторике,
већ да уочиш да се три пута позива функција факторијел, наравно за различите
вредности параметара.

```{infonote}
Вероватно си из математике већ учио да се факторијел неког броја *n*
рачуна по формули n! = n * (n-1) * (n-2) * … * 1, при чему се узима у обзир да је 0! = 1.
На пример 6! = 6 * 5 * 4 * 3 * 2 * 1.
```

Прво креирамо функцију факторијел:

```c
long faktorijel(int k)
{
    int i;
    long p = 1;
    for (i = 1; i <= k; i++)
        p *= i;
    return p;
}
```

Прво што уочаваш је тип функције. Зашто `long`? Са повећањем броја *n* знатно се повећава
његов факторијел, тако да се за релативно мале вредности *n* излази из опсега *int. Покушај
да нађеш факторијел за бројеве 10, 20, 50. Шта примећујеш? Иначе, ово није једини случај
где мораш да водиш рачуна о прекорачењу вредности. То је рецимо проблем налажења
Фибоначијевих бројева. И многих других. Препоручујемo ти и да прочиташ легенду о шаху, има
итекако везе са овом причом.

Поштујући редослед множења, кôд факторијела могли смо написати и овако:

```c
for (i = k; i >= 1 ; i--)
    p *= i;
```

Резултат је наравно исти.

**Главни програм**:

У главном програму ћемо само проследити различите вредности параметара нашој креираној
функцији, према изразу.

```c

int main(void)
{
    long k;
    int n, m;
    printf("Unesi broj elemenata: ");
    scanf("%d", &n);
    printf("Unesi klasu elemenata: ");
    scanf("%d", &m);
    k = faktorijel(n) / (faktorijel(m) * faktorijel(m - n));
    printf("Broj kombinacija %d elemenata %d. klase je %ld\n", n, m, k);
    return 0;
}
```

**Резултат извршавања програма**:

```text
Unesi broj elemenata: 5
Unesi klasu elemenata: 3
Broj kombinacija 5 elemenata 3. klase je 20
```

```{questionnote}
Програм који рачуна минимални и максимални од четири учитана броја a, b, c и d
коришћењем функција max(a,b), min(a,b).
```

**Решење**:

Прво што уочаваш је да имамо четири броја за поређење, али морамо да користимо
функцију која има само два параметра.

```c
int max(int a, int b)
{
    if (a > b)
        return a;
    return b;
}
int min(int a, int b)
{
    if (a < b)
        return a;
    return b;
}
```

Шта уочаваш у овим функцијама? Наредба `return` се јавила у коду два пута, али се
позива само једном, у зависности од услова. О овом правилу, да функција враћа само
једну вредност, већ смо причали.

```{infonote}
Ове функције смо могли да урадимо и коришћењем тернарног оператора који је јако захвалан
за рад са функцијама:

int min(int a, int b)
{return (a < b) ? a : b;}

int max(int a, int b)
{return (a > b) ? a : b;}

Да се подсетимо значења, учио си ову наредбу у првом разреду: ако је услов у загради испуњен, израз
добија вредност а која се наредбом `return` враћа у главни програм. У супротном враћа се вредност `b`.

Употребом тернарног оператора задаци овог типа се раде елегантније, а број линија кода се смањује.
```

Како да употребимо ове функције у главном програму? Сетимо се ограничења да имамо четири броја, а
функције са два параметра. Идеја је да, користећи функцију max, нађемо већи од прва два броја,
односно последња два.

Функцијом max налазимо већи од прва два, односно друга два броја, а затим те вредности користимо
као параметре исте те функције:

```{image} images/Picture6.png
:width: 250
:align: center
```

Исти начин решавања проблема важи и за функцију `min`.

Главни програм:

```c
int main(void)
{
    int a, b, c, d;
    printf("Ucitajte broj a, b, c, d: ");
    scanf("%d%d%d%d", &a, &b, &c, &d);
    printf("Najveci broj je %d\n", max(max(a, b), max(c, d)));
    printf("Najmanji broj je %d", min(min(a, b), min(c, d)));
    return 0;
}
```

Резултат извршавања програма:

```text
Ucitajte broj a, b, c, d: 4 8 9 3
Najveci broj je 9
Najmanji broj je 3
```
